# 객체 생성 캡슐화 하기
- **정의:** 객체를 생성하는 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정하도록 하는 패턴입니다.
- **목적:** 클래스 간의 결합도도 낮추고, 직접적인 객체 생성(new)의 책임을 분리하여 코드 변화에 유연하게 대응하기 위함입니다.

# 팩토리 메소드 패턴

알고리즘의 뼈대를 부모가 잡는 템플릿 메소드 패턴처럼, 팩토리 메소드 패턴은 **객체 생성의 흐름**을 부모 클래스에 정의하고, **실제 어떤 객체를 만들지**는 자식 클래스에서 구현하도록 하는 생성 디자인 패턴입니다.

- **추상 생산자**(Abstract Creator): 객체를 만드는 factoryMethod()를 선언합니다. 이 메소드를 호출하여 제품을 사용하는 비즈니스 로직(템플릿과 유사한 흐름)을 가집니다.
- **구체적 생산자**(Concrete Creator): 부모의 메소드를 재정의하여 실제 제품(Concrete Product) 객체를 생성하여 반환합니다.
- **제품**(Product): 생성될 객체들의 공통 인터페이스입니다.

# 팩토리 메소드 패턴의 핵심 원칙

- **상속 기반의 생성**: 템플릿 메소드 패턴과 마찬가지로 **상속**을 통해 구현됩니다. 부모 클래스는 "언제" 객체가 필요한지만 결정하고, 자식 클래스가 "무엇을" 만들지 결정합니다.
- **의존성 역전 원칙**(DIP): 구체적인 클래스 이름에 의존하지 않고 추상화된 인터페이스에 의존하게 하여, 새로운 제품이 추가되어도 기존 생산자 코드를 수정할 필요가 없습니다.
- **생성 로직의 집중화**: new 키워드가 흩어져 있는 것을 한곳(팩토리)으로 모아 관리 효율성을 높입니다.

# 팩토리 메소드의 장단점
- 장점: 제품 클래스와 사용자 클래스 간의 결합도를 낮춥니다(Loose Coupling). 개방-폐쇄 원칙(OCP)을 준수하여 기존 코드를 건드리지 않고도 새로운 제품군을 추가하기 쉽습니다.
- 단점: 각 제품마다 새로운 자식 클래스를 만들어야 하므로 클래스 개수가 많아져 구조가 복잡해질 수 있습니다.

# 나의 고찰?
앞서 공부했던 템플릿 메소드가 **상속**을 통해 알고리즘의 일부를 서브클래스에 맡겼던 것처럼, 팩토리 패턴도 결국 '어떤 객체를 만들지'를 결정하는 과정에서 클래스 구조가 고정될 수 있다는 위험을 느꼈습니다.
팩토리 패턴에서도 단순히 팩토리를 분리하는 것을 넘어 **어떻게 하면 더 유연하게 객체 생성 방식을 갈아 끼울 수 있을지** 고민하는 것이 중요하다는 것을 깨달았습니다.
