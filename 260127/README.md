# 알고리즘 캡슐화 하기

## 알고리즘 캡슐화
- 정의: 동일한 계열의 알고리즘들을 각각의 클래스로 캡슐화하여 공통의 인터페이스를 통해 상호 교체 가능하게 만드는 것입니다.
- 목적: 클라이언트와 상관없이 알고리즘을 독립적으로 변경하거나 확장할 수 있도록 하기 위함입니다.

**알고리즘 캡슐화**는 이전 시간 전략 패턴에서도 사용 했던 내용입니다. 두 패턴 모두 '변하는 것을 캡슐화한다'는 공통된 디자인 원칙을 따르지만, 템플릿 메소드 패턴은 이 원칙을 '**상속**'을 통해, 전략 패턴은 '**구성**'을 통해 구현한다는 점에서 차이가 있다.

# 템플릿 메소드 패턴
- 알고리즘의 전체적인 골격은 부모 클래스에 정의하고, 구체적인 처리 단계는 자식 클래스에서 구현하도록 하는 행위 디자인 패턴입니다. 이패턴을 활용하면 전체적인 알고리즘 구조를 유지하면서도 특정 단계의 세부 동작을 유연하게 변경할 수 있습니다.

- **추상 클래스(Abstract Class)** : 알고리즘의 뼈대가 되는 템플릿 메소드를 구현합니다. 이 메소드는 여려 단계로 구성된 메소드 호출을 포함합니다.
- **추상 메소드(Abstract Method)** : 자식 클래스에서 반드시 재정의해야하는 단계입니다.
- **훅 메소드(Hook Method)** : 부모 클래스에 기본 구현이 되어 있거나 비어 있는 메소드로, 자식 클래스에서 필요에 따라 선택적으로 오버라이드 할 수 있습니다.

# 템플릿 메소드 패턴의 핵심 원칙
- **상속 기반 설계**: 이 패턴은 객체 간의 상속 관계를 핵심으로 합니다. 부모 클래스가 알고리즘의 뼈대를 정의하고, 자식 클래스가 그 일부를 구현합니다. 이는 "나는 ~이다(Is-A)" 관계를 형성합니다.
- **알고리즘 구조의 고정**: 부모 클래스의 템플릿 메소드 내에서 호출되는 메소드들의 순서와 구조는 절대 변하지 않습니다. 알고리즘의 전체 흐름은 부모 클래스가 꽉 잡고 있습니다.
- **일부 단계의 구현 위임**: 알고리즘 중 변하는 부분(예: 재료 넣기)만 추상 메소드나 훅 메소드로 정의하여 자식 클래스에게 구현을 맡깁니다. 이는 전체 흐름을 유지하면서 세부 동작에 대한 확장성을 제공합니다.
부모 주도의 흐름 제어: 누가 언제 어떤 메소드를 호출할지 부모 클래스가 결정합니다. 자식 클래스는 호출당하는 입장이며, 부모의 제어 흐름에 종속됩니다.

# 템플릿 메소드 장단점
- 장점 : 중복 코드를 제거하고 코드 재사용성을 높입니다. 공통 로직을 한곳으로 관리하여 유지보수가 쉽습니다.
- 단점 : 하위 클래스가 상위 클래스에 강하게 의존하게 되어 설계의 유연성이 떨어질 수 있습니다. 상속 구조가 복잡해지면 코드 흐름을 파악하기 어려울 수 있습니다.



"**템플릿 메소드 패턴**은 분명 **알고리즘의 골격을 유지한 채** 세부 동작을 변경할 수 있어 **초기 유지보수에는 유리**해 보입니다.
하지만 **상속**(Inheritance)을 통한 상위 클래스와 하위 클래스 간의 **강한 결합**이 문제입니다.
알고리즘의 전체 흐름이 단 한 단계라도 바뀌면 모든 자식 클래스에 영향을 미치게 되는데,
이런 **구조적 취약함**을 고려한다면 과연 진정한 의미에서 **유지보수가 쉽다고 할 수 있을지 의문**이 듭니다.
그래서 템플릿 메소드 패턴의 한계를 보완할 수 있도록, 상속이 아닌 '구성'을 활용해 더 유연하게 알고리즘을 갈아 끼우는 **전략 패턴**(Strategy Pattern)'도 깊이 있게 공부하여 상황에 맞는 적절한 선택지를 갖춰야겠다고 느꼈습니다"
